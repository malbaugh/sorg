<style>
    /* Fixed overlay that sits behind all page content */
    .scroll-gradient-bg {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 0;
        contain: paint;
    }

    /* Inner container that moves with scroll to create the gradient effect */
    .scroll-gradient-bg__inner {
        width: 100%;
        height: 100%;
        will-change: transform;
    }

    /* Lift all page content above the overlay without needing a wrapper */
    .has-scroll-gradient> :not(.scroll-gradient-bg) {
        position: relative;
        z-index: 1;
    }
</style>

<script>
    // Because this fix needs to run inline, immediately after <body>, and in a
    // specific order with other template-driven UI bits (like dark mode), I made 
    // it a small template partial instead of a separate JS asset. That lets it 
    // execute early enough to avoid flicker/double-paint, guarantees ordering, 
    // and avoids an extra network request for a tiny, critical rendering path 
    // script.

    (function () {
        try {
            // Early exit if browser doesn't support required features
            if (!('requestAnimationFrame' in window) || !document.body) return;

            var body = document.body;
            // Only run on pages that have the gradient background class
            if (!body.classList.contains('bg-gradient-to-br')) return;
            // Prevent multiple initializations
            if (window.__sorgScrollGradientInitialized) return;
            window.__sorgScrollGradientInitialized = true;

            // Check if browser supports CSS containment for better performance
            var supportsContain =
                (window.CSS && CSS.supports && (CSS.supports('contain: paint') || CSS.supports('contain: strict'))) || false;

            // DOM elements and state variables
            var container = null;
            var inner = null;
            var rafId = null;
            var lastScrollY = -1;
            var resizeObserver = null;

            // Track original body background to restore later
            var bodyInlineBackgroundImageOriginal = '';
            var bodyBackgroundOverridden = false;

            /**
             * Copy computed background styles from body to the gradient overlay
             * This ensures the gradient matches the current theme/class state
             */
            function copyComputedBackground(target) {
                var restoreInlineBackgroundImage = null;
                if (bodyBackgroundOverridden) {
                    restoreInlineBackgroundImage = body.style.backgroundImage;
                    body.style.backgroundImage = bodyInlineBackgroundImageOriginal || '';
                }

                var cs = getComputedStyle(body);

                // Copy all background properties to container
                if (target === container && container) {
                    container.style.backgroundColor = cs.backgroundColor;
                    container.style.backgroundImage = cs.backgroundImage;
                    container.style.backgroundRepeat = cs.backgroundRepeat;
                    container.style.backgroundSize = cs.backgroundSize;
                    container.style.backgroundPosition = cs.backgroundPosition;
                } 
                // Copy background properties to inner element
                else if (target === inner && inner) {
                    container.style.backgroundColor = cs.backgroundColor;
                    inner.style.backgroundImage = cs.backgroundImage;
                    inner.style.backgroundRepeat = cs.backgroundRepeat;
                    inner.style.backgroundSize = cs.backgroundSize;
                    inner.style.backgroundPosition = cs.backgroundPosition;
                }

                // Restore any inline background that was temporarily removed
                if (restoreInlineBackgroundImage !== null) {
                    body.style.backgroundImage = restoreInlineBackgroundImage;
                }
            }

            /**
             * Set the height of the inner gradient element to cover the full document
             * This ensures the gradient extends beyond the viewport for smooth scrolling
             */
            function setHeight() {
                if (!inner) return;
                var doc = document.documentElement;
                var docHeight = Math.max(
                    doc.scrollHeight,
                    body.scrollHeight,
                    doc.offsetHeight,
                    body.offsetHeight
                );
                // Add 4px buffer to prevent any gaps during scroll
                inner.style.height = (docHeight + 4) + 'px';
            }

            /**
             * Handle scroll events by updating the gradient position
             * Uses requestAnimationFrame for smooth performance
             */
            function onScroll() {
                if (!inner) return;
                if (rafId != null) return;
                rafId = window.requestAnimationFrame(function () {
                    rafId = null;
                    var dpr = window.devicePixelRatio || 1;
                    var y = Math.round(window.scrollY * dpr) / dpr;
                    if (y === lastScrollY) return;
                    lastScrollY = y;
                    inner.style.transform = 'translateY(' + (-y) + 'px)';
                });
            }

            /**
             * Handle resize events by recalculating height and scroll position
             */
            function onResize() {
                setHeight();
                onScroll();
            }

            // Keep gradient in sync with theme/class changes
            var mo = new MutationObserver(function (mutations) {
                for (var i = 0; i < mutations.length; i++) {
                    if (mutations[i].type === 'attributes' && mutations[i].attributeName === 'class') {
                        copyComputedBackground(inner ? inner : container);
                        break;
                    }
                }
            });
            mo.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
            mo.observe(body, { attributes: true, attributeFilter: ['class'] });

            // --- Initialization ---
            if (supportsContain) {
                // Create the gradient overlay container
                container = document.createElement('div');
                container.className = 'scroll-gradient-bg';

                // Create the inner element that will move with scroll
                inner = document.createElement('div');
                inner.className = 'scroll-gradient-bg__inner';
                container.appendChild(inner);

                // Copy current background styles and set initial dimensions
                copyComputedBackground(inner);
                setHeight();
                onScroll();

                // Add the overlay to the page
                body.appendChild(container);

                // Store original body background and clear it
                bodyInlineBackgroundImageOriginal = body.style.backgroundImage;
                body.style.backgroundImage = 'none';
                bodyBackgroundOverridden = true;

                // Ensure all body children paint above the overlay
                body.classList.add('has-scroll-gradient');

                // Set up resize observer for dynamic content changes
                if ('ResizeObserver' in window) {
                    resizeObserver = new ResizeObserver(function () { setHeight(); });
                    resizeObserver.observe(document.documentElement);
                }
                // Add event listeners for scroll and resize
                window.addEventListener('scroll', onScroll, { passive: true });
                window.addEventListener('resize', onResize);
            }

            // Cleanup function to remove all event listeners and DOM elements
            window.addEventListener('pagehide', function () {
                if (rafId != null) cancelAnimationFrame(rafId);
                window.removeEventListener('scroll', onScroll);
                window.removeEventListener('resize', onResize);
                if (resizeObserver) resizeObserver.disconnect();
                if (container && container.parentNode) container.parentNode.removeChild(container);
                if (bodyBackgroundOverridden) body.style.backgroundImage = bodyInlineBackgroundImageOriginal || '';
                body.classList.remove('has-scroll-gradient');
                mo.disconnect();
                window.__sorgScrollGradientInitialized = false;
            });
        } catch {
            // If we get an error, we can fail silently as we fallback to the
            // original styling.
        }
    })();
</script>